## 前情提要 —— 一种常见的Event对象的实现：
```javascript
function initEventMap(events = {}, eventName) {
	events[eventName] = events[eventName] || [];
	return events[eventName]; 
}
class FEvent {
	constructor() {
		this.events = {}; // 存储绑定的事件
	}
	$on(eventName, handle) {
		initEventMap(this.events, eventName).push(handle);
	}
	$emit(eventName, data) {
		initEventMap(this.events, eventName).forEach(handle);
	}
	$off(eventName) {}
}
```

### 缺陷
1. 以继承方式使用时，定义的class需要声明 events 属性，使用麻烦；
2. 如果期望 events 作为私有属性存在，即往后可能改变名称或实现方式，导致继承的对象 events 属性声明失效；
3. 接收事件响应反馈

## 使用方式分析

### 使用姿势：全局方式
```javascript
[global].event = new FEvent();

//or in event module file
export new FEvent();
```

历史上我干过不少这种事，比如在Vue框架下，以
	
	export new Vue()

的方式作为事件模块使用，这样所有事件都指向同一个事件实例。一般倒也没什么问题，但是中大型应用中事件的管理可能会有点麻烦：
	
1. 需要留意 eventName 的定义：为了避免重名可能通常会需要加上一些前缀，eg:
```javascript
event.$on('article-update', doSth)
event.$on('article-tag-update', doSth)
event.$on('article-title-update', doSth)
```
2. 关注事件解绑：事件实例是一个全局的实例，被绑定的事件及其引用的上下文环境，在不解绑的情况下，将不能被释放，这可能会引起内存泄漏。


### 与业务实例绑定
DOM、VueComponent 等，都是这种方式

#### 优点
1. 一般不用担心事件未解绑带来的内存泄漏问题，只要实例能正常销毁即可
2. 可以减少对事件来源的判断，在特定的业务场景下，这会很有用
3. 一般不用担心事件定义重名问题

#### 继承方式
```javascript
class A extends FEvent {
	constructor{
		this.events = {}; // 用于存储实例上的事件
	}
}

// use
const aInstance = new A();
aInstance.$on(...);
aInstance.$emit(...);
```
#### mixin
```javascript
function mixinEvent(target) {
    const protos = FEvent.prototype;
    /* eslint-disable no-param-reassign */
    Object.getOwnPropertyNames(protos).forEach((key) => {
        if (key === 'constructor') {
            return;
        }
        target.prototype[key] = protos[key];
    });
    target.events = {};
}
class A {}
mixinEvent(A);

// use
const aInstance = new A();
aInstance.$on(...);
aInstance.$emit(...);
```

#### decorates
```javascript
@mixinEvent // 实现同 mixin
class A {}
```

### 使用场景
1. 发布订阅者模式
2. 组件通信
3. 组件间方法调用，以 vue 为例，避免 ref 的使用


### 事件的缺陷
1. 不能接收某次事件调用的反馈 （学习DOMEvent 的实现）
<!--stackedit_data:
eyJoaXN0b3J5IjpbNzQ0NTgxNjU3LC02OTY0MDA3MzQsLTE0Mj
k2Nzk3MjVdfQ==
-->